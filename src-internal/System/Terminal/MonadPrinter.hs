{-# LANGUAGE TypeFamilies     #-}
{-# LANGUAGE FlexibleContexts #-}
module System.Terminal.MonadPrinter where

import           Data.Text                     as T
import           Data.Text.Prettyprint.Doc

import           Prelude                   hiding (putChar)

-- | This class describes an environment that Unicode text can be printed to.
--   This might either be file or a terminal.
--
--    * Instances shall implement the concept of lines and line width.
--    * Instances shall implement the concept of a carriage that can be
--      set to the beginning of the next line.
--    * It is assumed that the carriage automatically moves to the beginning
--      of the next line if the end of the current line is reached.
--    * Instances shall be Unicode aware or must at least be able to print
--      a replacement character.
--    * Implementations must be aware of infinite lazy `Prelude.String`s and
--      long `Data.Text.Text`s. `String`s should be printed character wise as
--      evaluating them might trigger exceptions at any point. Long text should
--      be printed chunk wise in order to stay interruptible.
--    * Implementations must not use an unbounded output buffer. Print operations
--      shall block and be interruptible when the output buffer is full.
--    * Instances shall not interpret any control characters but
--      \\n (new line, as generated by `putLn`, and \\t (horizontal tabulator).
--    * Especially escape sequences shall be filtered or at least defused
--      by removing the leading \\ESC. Text formatting shall be done with the
--      designated classes like `MonadPrettyPrinter`, `MonadFormatPrinter`
--      and `MonadColorPrinter`. Allowing control sequences would cause a
--      dependency on certain terminal types, but might also be an underrated
--      security risk as modern terminals are highly programmable and should
--      not be fed with untrusted input.
class Monad m => MonadPrinter m where
    -- | Move the carriage to the beginning of the next line.
    putLn              :: m ()
    putLn               = putChar '\n'
    -- | Print a single printable character or one of the allowed control characters.
    putChar            :: Char -> m ()
    -- | Print a `String`.
    putString          :: String -> m ()
    putString           = mapM_ putChar
    -- | Print a `String` and an additional newline.
    putStringLn        :: String -> m ()
    putStringLn s       = putString s >> putLn
    -- | Print a `Text`.
    putText            :: Text -> m ()
    putText             = putString . T.unpack
    -- | Print a `Text` and an additional newline.
    putTextLn          :: Text -> m ()
    putTextLn           = putStringLn . T.unpack
    -- | Flush the output buffer and make the all previous output actually
    --   visible after a reasonably short amount of time.
    --
    --    * The operation may return before the buffer has actually been flushed.
    flush              :: m ()
    flush               = pure ()
    -- | Get the current line width.
    --
    --    * The operation may return the last known line width and may not be
    --      completely precise when I/O is asynchronous.
    --    * This operations shall not block too long and rather be called more
    --      often in order to adapt to changes in line width.
    getLineWidth       :: m Int
    {-# MINIMAL putChar, getLineWidth #-}

-- | This class introduces abstract constructors for text markup.
class MonadPrinter m => MonadMarkupPrinter m where
    -- | This associated type represents all possible attributes that are
    --   available in the current environment.
    --
    --   When writing polymorphic code against these monadic interfaces
    --   the concrete instantiation of this type is usually unknown and class
    --   instances are generally advised to not expose value constructors for
    --   this type.
    --
    --   Instead, subclasses like `MonadFormatPrinter` and `MonadColorPrinter`
    --   offer abstract value constructors like `bold`, `underlined`, `inverted`
    --   which are then given meaning by the concrete class instance. The
    --   environment `System.Terminal.Ansi.AnsiTerminalT` for example
    --   implements all of these classes.
    data Attribute m
    setAttribute :: Attribute m -> m ()
    setAttribute _ = pure ()
    -- | Reset an attribute so that it does no longer affect subsequent output.
    --
    -- * Binary attributes like `bold` or `underlined` shall just be reset to their opposite.
    --
    -- * For non-binary attributes like colors all of their possible values shall be treated
    --   as equal, so that
    --
    --   @
    --   `setAttribute` (`foreground` $ `bright` `Blue`) >> `resetAttribute` (`foreground` $ `dull` `Red`)
    --   @
    --
    --   results in the foreground color attribute reset afterwards whereas after
    --
    --   @
    --   `setAttribute` (`foreground` $ `bright` `Blue`) >> `resetAttribute` (`background` $ `dull` `Red`)
    --   @
    --
    --   the foreground color is still set as `bright` `Blue`.
    --
    resetAttribute  :: Attribute m -> m ()
    -- | Reset all attributes to their default.
    resetAttributes :: m ()
    -- | Shall determine wheter two attribute values would override each other
    --   or can be applied independently.
    --
    -- * Shall obey the laws of equivalence.
    resetsAttribute :: Attribute m -> Attribute m -> Bool

class MonadMarkupPrinter m => MonadFormattingPrinter m where
    -- | This attribute makes text appear __bold__.
    bold            :: Attribute m
    -- | This attribute makes text appear /italic/.
    italic          :: Attribute m
    -- | This attribute makes text appear underlined.
    underlined      :: Attribute m
    -- | This attribute swaps foreground and background (color).
    --
    --   * This operation is idempotent: Applying the attribute a second time
    --     won't swap it back. Use `resetAttribute` instead.
    inverted        :: Attribute m

-- | This class offers abstract value constructors for
--   foreground and background coloring.
class MonadMarkupPrinter m => MonadColorPrinter m where
    data Color m

    black      :: Color m
    red        :: Color m
    green      :: Color m
    yellow     :: Color m
    blue       :: Color m
    magenta    :: Color m
    cyan       :: Color m
    white      :: Color m

    bright     :: Color m -> Color m

    -- | This attribute sets the __foreground__ color (the text color).
    foreground :: Color m -> Attribute m
    -- | This attribute sets the __background__ color.
    background :: Color m -> Attribute m

-- | Print an annotated `Doc`.
--
--   * This operation performs `resetAttributes` on entry and on exit.
--   * This operation can deal with nested attributes (see example).
--
-- Example:
--
-- @
-- {-# LANGUAGE OverloadedStrings #-}
-- import System.Terminal
-- import Data.Text.Prettyprint.Doc
--
-- printer :: (`MonadFormatPrinter` m, `MonadColorPrinter` m) => m ()
-- printer = `putDoc` $ `annotate` (foreground $ `bright` `Blue`) "This is blue!" <> `line`
--                 <> `annotate` `bold` ("Just bold!" <> otherDoc <> "..just bold again")
--
-- otherDoc :: (`MonadColorPrinter` m, `Attribute` m ~ ann) => `Doc` ann
-- otherDoc = `annotate` (`background` $ `dull` `Red`) " BOLD ON RED BACKGROUND "
-- @
--
-- Note the necessary unification of `Attribute` `m` and `ann` in the definition of `otherDoc`!
putDoc :: (MonadMarkupPrinter m) => Doc (Attribute m) -> m ()
putDoc doc = do
    w <- getLineWidth
    putSimpleDocStream (sdoc w)
    where
        options w = defaultLayoutOptions { layoutPageWidth = AvailablePerLine w 1.0 }
        sdoc w    = layoutSmart (options w) doc

-- | Like `putDoc` but adds an additional newline.
putDocLn :: (MonadMarkupPrinter m) => Doc (Attribute m) -> m ()
putDocLn doc = putDoc doc >> putLn

-- | TODO: documentation
putSimpleDocStream :: (MonadMarkupPrinter m) => SimpleDocStream (Attribute m) -> m ()
putSimpleDocStream sdoc = do
    resetAttributes
    f [] sdoc
    where
        f _       SFail          = pure ()
        f _       SEmpty         = pure ()
        f    aa  (SChar c    xx) = putChar c                             >> f    aa  xx
        f    aa  (SText _ t  xx) = putText t                             >> f    aa  xx
        f    aa  (SLine i    xx) = putLn >> putText (T.replicate i " ")  >> f    aa  xx
        f    aa  (SAnnPush a xx) = setAttribute a                        >> f (a:aa) xx
        f (a:aa) (SAnnPop    xx) = case Prelude.filter (resetsAttribute a) aa of
            []    -> resetAttribute a >> f aa xx
            (e:_) -> setAttribute   e >> f aa xx
